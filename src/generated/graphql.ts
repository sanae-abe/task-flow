// @ts-nocheck
/* eslint-disable */
/**
 * GraphQL Types - Auto-generated from schema
 * DO NOT EDIT MANUALLY
 *
 * Generated by GraphQL Code Generator
 * @see codegen.yml for configuration
 */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client/react';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** ISO 8601 date-time string (e.g., "2025-11-08T10:30:00Z") */
  DateTime: { input: string; output: string; }
  /** Arbitrary JSON data */
  JSON: { input: Record<string, unknown>; output: Record<string, unknown>; }
};

export type AiContextInput = {
  readonly boardId?: InputMaybe<Scalars['ID']['input']>;
  readonly preferences?: InputMaybe<UserPreferencesInput>;
  readonly recentActivity?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

export type AiSuggestion = {
  readonly __typename?: 'AISuggestion';
  readonly actions: ReadonlyArray<SuggestedAction>;
  readonly confidence: Scalars['Float']['output'];
  readonly message: Scalars['String']['output'];
  readonly task?: Maybe<Task>;
  readonly type: SuggestionType;
};

/** Access log entry with geolocation data */
export type AccessLog = {
  readonly __typename?: 'AccessLog';
  readonly endpoint?: Maybe<Scalars['String']['output']>;
  readonly geolocation?: Maybe<GeolocationData>;
  readonly id: Scalars['ID']['output'];
  readonly ip: Scalars['String']['output'];
  readonly timestamp: Scalars['DateTime']['output'];
  readonly userAgent?: Maybe<Scalars['String']['output']>;
};

/** Geographic access statistics */
export type AccessStats = {
  readonly __typename?: 'AccessStats';
  readonly recentAccess: ReadonlyArray<AccessLog>;
  readonly topCities: ReadonlyArray<CityStats>;
  readonly topCountries: ReadonlyArray<CountryStats>;
  readonly totalRequests: Scalars['Int']['output'];
  readonly uniqueIPs: Scalars['Int']['output'];
};

export type Attachment = {
  readonly __typename?: 'Attachment';
  readonly data: Scalars['String']['output'];
  readonly id: Scalars['ID']['output'];
  readonly name: Scalars['String']['output'];
  readonly size: Scalars['Int']['output'];
  readonly storagePath?: Maybe<Scalars['String']['output']>;
  readonly type: Scalars['String']['output'];
  readonly uploadedAt: Scalars['DateTime']['output'];
};

export type AttachmentInput = {
  readonly data: Scalars['String']['input'];
  readonly name: Scalars['String']['input'];
  readonly size: Scalars['Int']['input'];
  readonly type: Scalars['String']['input'];
};

export type Board = {
  readonly __typename?: 'Board';
  readonly columns: ReadonlyArray<BoardColumn>;
  readonly columnsWithTasks: ReadonlyArray<Column>;
  readonly completedTaskCount: Scalars['Int']['output'];
  readonly createdAt: Scalars['DateTime']['output'];
  readonly deletedAt?: Maybe<Scalars['DateTime']['output']>;
  readonly deletionState: DeletionState;
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  readonly isShared: Scalars['Boolean']['output'];
  readonly labels: ReadonlyArray<Label>;
  readonly name: Scalars['String']['output'];
  readonly settings: BoardSettings;
  readonly taskCount: Scalars['Int']['output'];
  readonly title: Scalars['String']['output'];
  readonly updatedAt: Scalars['DateTime']['output'];
};

export type BoardColumn = {
  readonly __typename?: 'BoardColumn';
  readonly color?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  readonly position: Scalars['Int']['output'];
  readonly taskCount: Scalars['Int']['output'];
  readonly title: Scalars['String']['output'];
};

export type BoardColumnInput = {
  readonly color?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['ID']['input']>;
  readonly position: Scalars['Int']['input'];
  readonly title: Scalars['String']['input'];
};

/** Board data in localStorage format for import */
export type BoardImportInput = {
  readonly columns: ReadonlyArray<ColumnImportInput>;
  readonly createdAt: Scalars['String']['input'];
  readonly deletedAt?: InputMaybe<Scalars['String']['input']>;
  readonly deletionState?: InputMaybe<Scalars['String']['input']>;
  readonly id: Scalars['String']['input'];
  readonly labels: ReadonlyArray<LabelImportInput>;
  readonly title: Scalars['String']['input'];
  readonly updatedAt: Scalars['String']['input'];
};

export type BoardSettings = {
  readonly __typename?: 'BoardSettings';
  readonly autoArchiveCompleted: Scalars['Boolean']['output'];
  readonly completedColumnId?: Maybe<Scalars['ID']['output']>;
  readonly defaultColumnId?: Maybe<Scalars['ID']['output']>;
  readonly recycleBinRetentionDays: Scalars['Int']['output'];
};

export type BoardSettingsInput = {
  readonly autoArchiveCompleted?: InputMaybe<Scalars['Boolean']['input']>;
  readonly completedColumnId?: InputMaybe<Scalars['ID']['input']>;
  readonly defaultColumnId?: InputMaybe<Scalars['ID']['input']>;
  readonly recycleBinRetentionDays?: InputMaybe<Scalars['Int']['input']>;
};

export enum BreakdownStrategy {
  BY_COMPLEXITY = 'BY_COMPLEXITY',
  BY_COMPONENT = 'BY_COMPONENT',
  BY_FEATURE = 'BY_FEATURE',
  BY_PHASE = 'BY_PHASE'
}

/** Statistics by city */
export type CityStats = {
  readonly __typename?: 'CityStats';
  readonly city: Scalars['String']['output'];
  readonly count: Scalars['Int']['output'];
  readonly country: Scalars['String']['output'];
  readonly percentage: Scalars['Float']['output'];
};

/** localStorage-compatible Column type with embedded tasks */
export type Column = {
  readonly __typename?: 'Column';
  readonly color?: Maybe<Scalars['String']['output']>;
  readonly deletedAt?: Maybe<Scalars['DateTime']['output']>;
  readonly deletionState: DeletionState;
  readonly id: Scalars['ID']['output'];
  readonly tasks: ReadonlyArray<Task>;
  readonly title: Scalars['String']['output'];
};

/** Column data in localStorage format */
export type ColumnImportInput = {
  readonly color?: InputMaybe<Scalars['String']['input']>;
  readonly deletedAt?: InputMaybe<Scalars['String']['input']>;
  readonly deletionState?: InputMaybe<Scalars['String']['input']>;
  readonly id: Scalars['String']['input'];
  readonly tasks: ReadonlyArray<TaskImportInput>;
  readonly title: Scalars['String']['input'];
};

/** Statistics by country */
export type CountryStats = {
  readonly __typename?: 'CountryStats';
  readonly count: Scalars['Int']['output'];
  readonly country: Scalars['String']['output'];
  readonly countryCode: Scalars['String']['output'];
  readonly percentage: Scalars['Float']['output'];
};

export type CreateBoardInput = {
  readonly columns?: InputMaybe<ReadonlyArray<BoardColumnInput>>;
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly name: Scalars['String']['input'];
};

export type CreateLabelInput = {
  readonly boardId?: InputMaybe<Scalars['ID']['input']>;
  readonly color: Scalars['String']['input'];
  readonly name: Scalars['String']['input'];
};

export type CreateSubTaskInput = {
  readonly position?: InputMaybe<Scalars['Int']['input']>;
  readonly title: Scalars['String']['input'];
};

export type CreateTaskInput = {
  readonly boardId: Scalars['ID']['input'];
  readonly columnId: Scalars['ID']['input'];
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly dueDate?: InputMaybe<Scalars['DateTime']['input']>;
  readonly dueTime?: InputMaybe<Scalars['String']['input']>;
  readonly files?: InputMaybe<ReadonlyArray<AttachmentInput>>;
  readonly labels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly priority?: InputMaybe<Priority>;
  readonly recurrence?: InputMaybe<RecurrenceConfigInput>;
  readonly subtasks?: InputMaybe<ReadonlyArray<CreateSubTaskInput>>;
  readonly title: Scalars['String']['input'];
};

export type CreateTemplateInput = {
  readonly category?: InputMaybe<Scalars['String']['input']>;
  readonly isFavorite?: InputMaybe<Scalars['Boolean']['input']>;
  readonly name: Scalars['String']['input'];
  readonly taskTemplate: TaskTemplateDataInput;
};

export type CreateWebhookInput = {
  readonly allowedIPs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly events: ReadonlyArray<WebhookEvent>;
  readonly rateLimit?: InputMaybe<Scalars['Int']['input']>;
  readonly secret?: InputMaybe<Scalars['String']['input']>;
  readonly url: Scalars['String']['input'];
};

export enum DeletionState {
  ACTIVE = 'ACTIVE',
  DELETED = 'DELETED'
}

/** File attachment in localStorage format */
export type FileImportInput = {
  readonly data: Scalars['String']['input'];
  readonly id: Scalars['String']['input'];
  readonly name: Scalars['String']['input'];
  readonly size: Scalars['Int']['input'];
  readonly type: Scalars['String']['input'];
  readonly uploadedAt: Scalars['String']['input'];
};

/** Geographic information from IP address */
export type GeolocationData = {
  readonly __typename?: 'GeolocationData';
  readonly asn?: Maybe<Scalars['String']['output']>;
  readonly city?: Maybe<Scalars['String']['output']>;
  readonly country?: Maybe<Scalars['String']['output']>;
  readonly countryCode?: Maybe<Scalars['String']['output']>;
  readonly ip: Scalars['String']['output'];
  readonly latitude?: Maybe<Scalars['Float']['output']>;
  readonly longitude?: Maybe<Scalars['Float']['output']>;
  readonly org?: Maybe<Scalars['String']['output']>;
  readonly region?: Maybe<Scalars['String']['output']>;
  readonly timezone?: Maybe<Scalars['String']['output']>;
};

/** Error during import process */
export type ImportError = {
  readonly __typename?: 'ImportError';
  readonly boardId?: Maybe<Scalars['String']['output']>;
  readonly code: Scalars['String']['output'];
  readonly field?: Maybe<Scalars['String']['output']>;
  readonly message: Scalars['String']['output'];
  readonly taskId?: Maybe<Scalars['String']['output']>;
};

/** Result of batch import from localStorage */
export type ImportResult = {
  readonly __typename?: 'ImportResult';
  readonly errors: ReadonlyArray<ImportError>;
  readonly importedBoardsCount: Scalars['Int']['output'];
  readonly importedTasksCount: Scalars['Int']['output'];
  readonly message: Scalars['String']['output'];
  readonly success: Scalars['Boolean']['output'];
};

export type Label = {
  readonly __typename?: 'Label';
  readonly boardId?: Maybe<Scalars['ID']['output']>;
  readonly color: Scalars['String']['output'];
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  readonly name: Scalars['String']['output'];
  readonly taskCount: Scalars['Int']['output'];
};

/** Label data in localStorage format */
export type LabelImportInput = {
  readonly color: Scalars['String']['input'];
  readonly id: Scalars['String']['input'];
  readonly name: Scalars['String']['input'];
};

export enum MarkdownFormat {
  GITHUB_FLAVORED = 'GITHUB_FLAVORED',
  OBSIDIAN = 'OBSIDIAN',
  STANDARD = 'STANDARD'
}

export type MarkdownMetadata = {
  readonly __typename?: 'MarkdownMetadata';
  readonly boardName: Scalars['String']['output'];
  readonly completedCount: Scalars['Int']['output'];
  readonly includeAttachments: Scalars['Boolean']['output'];
  readonly includeLabels: Scalars['Boolean']['output'];
  readonly includeSubtasks: Scalars['Boolean']['output'];
  readonly taskCount: Scalars['Int']['output'];
};

export type MarkdownReport = {
  readonly __typename?: 'MarkdownReport';
  readonly content: Scalars['String']['output'];
  readonly format: MarkdownFormat;
  readonly generatedAt: Scalars['DateTime']['output'];
  readonly metadata: MarkdownMetadata;
};

export type MarkdownReportInput = {
  readonly boardId: Scalars['ID']['input'];
  readonly filters?: InputMaybe<TaskFilters>;
  readonly format?: InputMaybe<MarkdownFormat>;
  readonly includeAttachments?: InputMaybe<Scalars['Boolean']['input']>;
  readonly includeCompleted?: InputMaybe<Scalars['Boolean']['input']>;
  readonly includeLabels?: InputMaybe<Scalars['Boolean']['input']>;
  readonly includeSubtasks?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Mutation = {
  readonly __typename?: 'Mutation';
  readonly breakdownTask: ReadonlyArray<Task>;
  readonly createBoard: Board;
  readonly createLabel: Label;
  readonly createTask: Task;
  readonly createTaskFromNaturalLanguage: Task;
  readonly createTasks: ReadonlyArray<Task>;
  readonly createTemplate: Template;
  readonly createWebhook: Webhook;
  readonly deleteBoard: Scalars['Boolean']['output'];
  readonly deleteLabel: Scalars['Boolean']['output'];
  readonly deleteTask: Scalars['Boolean']['output'];
  readonly deleteTasks: Scalars['Boolean']['output'];
  readonly deleteTemplate: Scalars['Boolean']['output'];
  readonly deleteWebhook: Scalars['Boolean']['output'];
  readonly duplicateTask: Task;
  readonly generateMarkdownReport: MarkdownReport;
  /** Import boards from localStorage format for Supabase migration */
  readonly importBoardsFromLocalStorage: ImportResult;
  readonly moveTask: Task;
  readonly optimizeTaskSchedule: ScheduleOptimization;
  readonly restoreTask: Task;
  readonly testWebhook: WebhookDelivery;
  readonly updateBoard: Board;
  readonly updateLabel: Label;
  readonly updateTask: Task;
  readonly updateTasks: ReadonlyArray<Task>;
  readonly updateTemplate: Template;
  readonly updateWebhook: Webhook;
};


export type MutationBreakdownTaskArgs = {
  strategy?: InputMaybe<BreakdownStrategy>;
  taskId: Scalars['ID']['input'];
};


export type MutationCreateBoardArgs = {
  input: CreateBoardInput;
};


export type MutationCreateLabelArgs = {
  input: CreateLabelInput;
};


export type MutationCreateTaskArgs = {
  input: CreateTaskInput;
};


export type MutationCreateTaskFromNaturalLanguageArgs = {
  context?: InputMaybe<AiContextInput>;
  query: Scalars['String']['input'];
};


export type MutationCreateTasksArgs = {
  inputs: ReadonlyArray<CreateTaskInput>;
};


export type MutationCreateTemplateArgs = {
  input: CreateTemplateInput;
};


export type MutationCreateWebhookArgs = {
  input: CreateWebhookInput;
};


export type MutationDeleteBoardArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteLabelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTaskArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTasksArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
};


export type MutationDeleteTemplateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteWebhookArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDuplicateTaskArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGenerateMarkdownReportArgs = {
  input: MarkdownReportInput;
};


export type MutationImportBoardsFromLocalStorageArgs = {
  boards: ReadonlyArray<BoardImportInput>;
};


export type MutationMoveTaskArgs = {
  id: Scalars['ID']['input'];
  targetColumnId: Scalars['ID']['input'];
  targetPosition: Scalars['Int']['input'];
};


export type MutationOptimizeTaskScheduleArgs = {
  boardId: Scalars['ID']['input'];
  constraints?: InputMaybe<ScheduleConstraints>;
};


export type MutationRestoreTaskArgs = {
  id: Scalars['ID']['input'];
};


export type MutationTestWebhookArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUpdateBoardArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBoardInput;
};


export type MutationUpdateLabelArgs = {
  id: Scalars['ID']['input'];
  input: UpdateLabelInput;
};


export type MutationUpdateTaskArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTaskInput;
};


export type MutationUpdateTasksArgs = {
  ids: ReadonlyArray<Scalars['ID']['input']>;
  input: UpdateTaskInput;
};


export type MutationUpdateTemplateArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTemplateInput;
};


export type MutationUpdateWebhookArgs = {
  id: Scalars['ID']['input'];
  input: UpdateWebhookInput;
};

export enum Priority {
  CRITICAL = 'CRITICAL',
  HIGH = 'HIGH',
  LOW = 'LOW',
  MEDIUM = 'MEDIUM'
}

export type PriorityBreakdown = {
  readonly __typename?: 'PriorityBreakdown';
  readonly critical: Scalars['Int']['output'];
  readonly high: Scalars['Int']['output'];
  readonly low: Scalars['Int']['output'];
  readonly medium: Scalars['Int']['output'];
};

export type Query = {
  readonly __typename?: 'Query';
  readonly aiSuggestedTasks: ReadonlyArray<Task>;
  readonly board?: Maybe<Board>;
  readonly boards: ReadonlyArray<Board>;
  readonly currentBoard?: Maybe<Board>;
  readonly exportBoardAsMarkdown: Scalars['String']['output'];
  readonly exportTaskAsMarkdown: Scalars['String']['output'];
  readonly exportTasksAsMarkdown: Scalars['String']['output'];
  /** Get access statistics with geolocation data */
  readonly getAccessStats: AccessStats;
  /** Get geolocation data for client IP */
  readonly getClientGeolocation?: Maybe<GeolocationData>;
  /** Get geolocation data for specific IP */
  readonly getIPGeolocation?: Maybe<GeolocationData>;
  readonly label?: Maybe<Label>;
  readonly labels: ReadonlyArray<Label>;
  readonly nextRecommendedTask?: Maybe<Task>;
  readonly searchTasksByNaturalLanguage: ReadonlyArray<Task>;
  readonly task?: Maybe<Task>;
  readonly taskStatistics: TaskStatistics;
  readonly tasks: ReadonlyArray<Task>;
  readonly template?: Maybe<Template>;
  readonly templates: ReadonlyArray<Template>;
  readonly webhook?: Maybe<Webhook>;
  readonly webhookDeliveries: ReadonlyArray<WebhookDelivery>;
  readonly webhookDelivery?: Maybe<WebhookDelivery>;
  readonly webhookStats: WebhookStats;
  readonly webhooks: ReadonlyArray<Webhook>;
};


export type QueryAiSuggestedTasksArgs = {
  context: AiContextInput;
};


export type QueryBoardArgs = {
  id: Scalars['ID']['input'];
};


export type QueryExportBoardAsMarkdownArgs = {
  boardId: Scalars['ID']['input'];
  filters?: InputMaybe<TaskFilters>;
};


export type QueryExportTaskAsMarkdownArgs = {
  taskId: Scalars['ID']['input'];
};


export type QueryExportTasksAsMarkdownArgs = {
  boardId: Scalars['ID']['input'];
  filters?: InputMaybe<TaskFilters>;
};


export type QueryGetAccessStatsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryGetIpGeolocationArgs = {
  ip: Scalars['String']['input'];
};


export type QueryLabelArgs = {
  id: Scalars['ID']['input'];
};


export type QueryLabelsArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryNextRecommendedTaskArgs = {
  boardId: Scalars['ID']['input'];
};


export type QuerySearchTasksByNaturalLanguageArgs = {
  query: Scalars['String']['input'];
};


export type QueryTaskArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTaskStatisticsArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryTasksArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
  dueAfter?: InputMaybe<Scalars['DateTime']['input']>;
  dueBefore?: InputMaybe<Scalars['DateTime']['input']>;
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  priority?: InputMaybe<Priority>;
  search?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<TaskStatus>;
};


export type QueryTemplateArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTemplatesArgs = {
  category?: InputMaybe<Scalars['String']['input']>;
  isFavorite?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryWebhookArgs = {
  id: Scalars['ID']['input'];
};


export type QueryWebhookDeliveriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  webhookId: Scalars['ID']['input'];
};


export type QueryWebhookDeliveryArgs = {
  id: Scalars['ID']['input'];
};

export type RecurrenceConfig = {
  readonly __typename?: 'RecurrenceConfig';
  readonly dayOfMonth?: Maybe<Scalars['Int']['output']>;
  readonly dayOfWeekInMonth?: Maybe<Scalars['Int']['output']>;
  readonly daysOfWeek?: Maybe<ReadonlyArray<Scalars['Int']['output']>>;
  readonly enabled: Scalars['Boolean']['output'];
  readonly endDate?: Maybe<Scalars['DateTime']['output']>;
  readonly interval: Scalars['Int']['output'];
  readonly maxOccurrences?: Maybe<Scalars['Int']['output']>;
  readonly pattern: RecurrencePattern;
  readonly weekOfMonth?: Maybe<Scalars['Int']['output']>;
};

export type RecurrenceConfigInput = {
  readonly dayOfMonth?: InputMaybe<Scalars['Int']['input']>;
  readonly dayOfWeekInMonth?: InputMaybe<Scalars['Int']['input']>;
  readonly daysOfWeek?: InputMaybe<ReadonlyArray<Scalars['Int']['input']>>;
  readonly enabled: Scalars['Boolean']['input'];
  readonly endDate?: InputMaybe<Scalars['DateTime']['input']>;
  readonly interval: Scalars['Int']['input'];
  readonly maxOccurrences?: InputMaybe<Scalars['Int']['input']>;
  readonly pattern: RecurrencePattern;
  readonly weekOfMonth?: InputMaybe<Scalars['Int']['input']>;
};

/** Recurrence config in localStorage format */
export type RecurrenceImportInput = {
  readonly dayOfMonth?: InputMaybe<Scalars['Int']['input']>;
  readonly dayOfWeekInMonth?: InputMaybe<Scalars['Int']['input']>;
  readonly daysOfWeek?: InputMaybe<ReadonlyArray<Scalars['Int']['input']>>;
  readonly enabled: Scalars['Boolean']['input'];
  readonly endDate?: InputMaybe<Scalars['String']['input']>;
  readonly interval: Scalars['Int']['input'];
  readonly maxOccurrences?: InputMaybe<Scalars['Int']['input']>;
  readonly pattern: Scalars['String']['input'];
  readonly weekOfMonth?: InputMaybe<Scalars['Int']['input']>;
};

export enum RecurrencePattern {
  DAILY = 'DAILY',
  MONTHLY = 'MONTHLY',
  WEEKLY = 'WEEKLY',
  YEARLY = 'YEARLY'
}

export type ScheduleConstraints = {
  readonly deadline?: InputMaybe<Scalars['DateTime']['input']>;
  readonly prioritizeBy?: InputMaybe<Priority>;
  readonly workingHoursPerDay?: InputMaybe<Scalars['Int']['input']>;
};

export type ScheduleOptimization = {
  readonly __typename?: 'ScheduleOptimization';
  readonly estimatedCompletionDate: Scalars['DateTime']['output'];
  readonly optimizedTasks: ReadonlyArray<Task>;
  readonly suggestions: ReadonlyArray<Scalars['String']['output']>;
};

export type StatusBreakdown = {
  readonly __typename?: 'StatusBreakdown';
  readonly completed: Scalars['Int']['output'];
  readonly deleted: Scalars['Int']['output'];
  readonly inProgress: Scalars['Int']['output'];
  readonly todo: Scalars['Int']['output'];
};

export type SubTask = {
  readonly __typename?: 'SubTask';
  readonly completed: Scalars['Boolean']['output'];
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  readonly position: Scalars['Int']['output'];
  readonly title: Scalars['String']['output'];
};

/** SubTask data in localStorage format */
export type SubTaskImportInput = {
  readonly completed: Scalars['Boolean']['input'];
  readonly createdAt: Scalars['String']['input'];
  readonly id: Scalars['String']['input'];
  readonly title: Scalars['String']['input'];
};

export type Subscription = {
  readonly __typename?: 'Subscription';
  readonly aiSuggestionAvailable: AiSuggestion;
  readonly boardUpdated: Board;
  readonly taskCompleted: Task;
  readonly taskCreated: Task;
  readonly taskDeleted: Task;
  readonly taskUpdated: Task;
};


export type SubscriptionAiSuggestionAvailableArgs = {
  boardId: Scalars['ID']['input'];
};


export type SubscriptionBoardUpdatedArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionTaskCompletedArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionTaskCreatedArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionTaskDeletedArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
};


export type SubscriptionTaskUpdatedArgs = {
  boardId?: InputMaybe<Scalars['ID']['input']>;
};

export type SuggestedAction = {
  readonly __typename?: 'SuggestedAction';
  readonly description: Scalars['String']['output'];
  readonly parameters?: Maybe<Scalars['JSON']['output']>;
  readonly type: Scalars['String']['output'];
};

export enum SuggestionType {
  BREAKDOWN_RECOMMENDED = 'BREAKDOWN_RECOMMENDED',
  DEADLINE_ALERT = 'DEADLINE_ALERT',
  NEXT_TASK = 'NEXT_TASK',
  PRIORITY_ADJUSTMENT = 'PRIORITY_ADJUSTMENT',
  RELATED_TASKS = 'RELATED_TASKS'
}

export type Task = {
  readonly __typename?: 'Task';
  readonly boardId: Scalars['ID']['output'];
  readonly columnId: Scalars['ID']['output'];
  readonly completedAt?: Maybe<Scalars['DateTime']['output']>;
  readonly completionPercentage: Scalars['Float']['output'];
  readonly createdAt: Scalars['DateTime']['output'];
  readonly deletedAt?: Maybe<Scalars['DateTime']['output']>;
  readonly deletionState: DeletionState;
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly dueDate?: Maybe<Scalars['DateTime']['output']>;
  readonly dueTime?: Maybe<Scalars['String']['output']>;
  readonly estimatedDuration?: Maybe<Scalars['Int']['output']>;
  readonly files: ReadonlyArray<Attachment>;
  readonly id: Scalars['ID']['output'];
  readonly isOverdue: Scalars['Boolean']['output'];
  readonly labels: ReadonlyArray<Label>;
  readonly occurrenceCount?: Maybe<Scalars['Int']['output']>;
  readonly position: Scalars['Int']['output'];
  readonly priority: Priority;
  readonly recurrence?: Maybe<RecurrenceConfig>;
  readonly recurrenceId?: Maybe<Scalars['String']['output']>;
  readonly status: TaskStatus;
  readonly subtasks: ReadonlyArray<SubTask>;
  readonly title: Scalars['String']['output'];
  readonly updatedAt: Scalars['DateTime']['output'];
};

export type TaskFilters = {
  readonly dueAfter?: InputMaybe<Scalars['DateTime']['input']>;
  readonly dueBefore?: InputMaybe<Scalars['DateTime']['input']>;
  readonly labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly priority?: InputMaybe<Priority>;
  readonly search?: InputMaybe<Scalars['String']['input']>;
  readonly status?: InputMaybe<TaskStatus>;
};

/** Task data in localStorage format */
export type TaskImportInput = {
  readonly completedAt?: InputMaybe<Scalars['String']['input']>;
  readonly createdAt: Scalars['String']['input'];
  readonly deletedAt?: InputMaybe<Scalars['String']['input']>;
  readonly deletionState?: InputMaybe<Scalars['String']['input']>;
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly dueDate?: InputMaybe<Scalars['String']['input']>;
  readonly files: ReadonlyArray<FileImportInput>;
  readonly id: Scalars['String']['input'];
  readonly labels: ReadonlyArray<LabelImportInput>;
  readonly occurrenceCount?: InputMaybe<Scalars['Int']['input']>;
  readonly priority?: InputMaybe<Scalars['String']['input']>;
  readonly recurrence?: InputMaybe<RecurrenceImportInput>;
  readonly recurrenceId?: InputMaybe<Scalars['String']['input']>;
  readonly subTasks: ReadonlyArray<SubTaskImportInput>;
  readonly title: Scalars['String']['input'];
  readonly updatedAt: Scalars['String']['input'];
};

export type TaskStatistics = {
  readonly __typename?: 'TaskStatistics';
  readonly averageCompletionTime?: Maybe<Scalars['Int']['output']>;
  readonly byPriority: PriorityBreakdown;
  readonly byStatus: StatusBreakdown;
  readonly completionRate: Scalars['Float']['output'];
  readonly overdueCount: Scalars['Int']['output'];
  readonly total: Scalars['Int']['output'];
};

export enum TaskStatus {
  COMPLETED = 'COMPLETED',
  DELETED = 'DELETED',
  IN_PROGRESS = 'IN_PROGRESS',
  TODO = 'TODO'
}

export type TaskTemplateData = {
  readonly __typename?: 'TaskTemplateData';
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly dueDate?: Maybe<Scalars['String']['output']>;
  readonly labels: ReadonlyArray<Label>;
  readonly priority?: Maybe<Priority>;
  readonly recurrence?: Maybe<RecurrenceConfig>;
  readonly subtasks: ReadonlyArray<SubTask>;
  readonly title: Scalars['String']['output'];
};

export type TaskTemplateDataInput = {
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly dueDate?: InputMaybe<Scalars['String']['input']>;
  readonly labels: ReadonlyArray<Scalars['ID']['input']>;
  readonly priority?: InputMaybe<Priority>;
  readonly recurrence?: InputMaybe<RecurrenceConfigInput>;
  readonly subtasks?: InputMaybe<ReadonlyArray<CreateSubTaskInput>>;
  readonly title: Scalars['String']['input'];
};

export type Template = {
  readonly __typename?: 'Template';
  readonly category?: Maybe<Scalars['String']['output']>;
  readonly createdAt: Scalars['DateTime']['output'];
  readonly id: Scalars['ID']['output'];
  readonly isFavorite: Scalars['Boolean']['output'];
  readonly name: Scalars['String']['output'];
  readonly taskTemplate: TaskTemplateData;
  readonly updatedAt: Scalars['DateTime']['output'];
};

export type UpdateBoardInput = {
  readonly columns?: InputMaybe<ReadonlyArray<BoardColumnInput>>;
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly settings?: InputMaybe<BoardSettingsInput>;
};

export type UpdateLabelInput = {
  readonly color?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateSubTaskInput = {
  readonly completed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly id: Scalars['ID']['input'];
  readonly position?: InputMaybe<Scalars['Int']['input']>;
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateTaskInput = {
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly dueDate?: InputMaybe<Scalars['DateTime']['input']>;
  readonly dueTime?: InputMaybe<Scalars['String']['input']>;
  readonly files?: InputMaybe<ReadonlyArray<AttachmentInput>>;
  readonly labels?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;
  readonly priority?: InputMaybe<Priority>;
  readonly recurrence?: InputMaybe<RecurrenceConfigInput>;
  readonly status?: InputMaybe<TaskStatus>;
  readonly subtasks?: InputMaybe<ReadonlyArray<UpdateSubTaskInput>>;
  readonly title?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateTemplateInput = {
  readonly category?: InputMaybe<Scalars['String']['input']>;
  readonly isFavorite?: InputMaybe<Scalars['Boolean']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly taskTemplate?: InputMaybe<TaskTemplateDataInput>;
};

export type UpdateWebhookInput = {
  readonly active?: InputMaybe<Scalars['Boolean']['input']>;
  readonly allowedIPs?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly events?: InputMaybe<ReadonlyArray<WebhookEvent>>;
  readonly rateLimit?: InputMaybe<Scalars['Int']['input']>;
  readonly secret?: InputMaybe<Scalars['String']['input']>;
  readonly url?: InputMaybe<Scalars['String']['input']>;
};

export type UserPreferencesInput = {
  readonly autoBreakdownEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  readonly preferredPriority?: InputMaybe<Priority>;
  readonly workingHours?: InputMaybe<WorkingHoursInput>;
};

export type Webhook = {
  readonly __typename?: 'Webhook';
  readonly active: Scalars['Boolean']['output'];
  readonly allowedIPs?: Maybe<ReadonlyArray<Scalars['String']['output']>>;
  readonly createdAt: Scalars['DateTime']['output'];
  readonly events: ReadonlyArray<WebhookEvent>;
  readonly id: Scalars['ID']['output'];
  readonly rateLimit?: Maybe<Scalars['Int']['output']>;
  readonly secret?: Maybe<Scalars['String']['output']>;
  readonly updatedAt: Scalars['DateTime']['output'];
  readonly url: Scalars['String']['output'];
};

export type WebhookDelivery = {
  readonly __typename?: 'WebhookDelivery';
  readonly deliveredAt: Scalars['DateTime']['output'];
  readonly event: WebhookEvent;
  readonly id: Scalars['ID']['output'];
  readonly payload: Scalars['JSON']['output'];
  readonly response?: Maybe<Scalars['JSON']['output']>;
  readonly status?: Maybe<Scalars['Int']['output']>;
  readonly success: Scalars['Boolean']['output'];
  readonly webhookId: Scalars['ID']['output'];
};

export enum WebhookEvent {
  BOARD_CREATED = 'BOARD_CREATED',
  BOARD_DELETED = 'BOARD_DELETED',
  BOARD_UPDATED = 'BOARD_UPDATED',
  TASK_COMPLETED = 'TASK_COMPLETED',
  TASK_CREATED = 'TASK_CREATED',
  TASK_DELETED = 'TASK_DELETED',
  TASK_UPDATED = 'TASK_UPDATED'
}

export type WebhookStats = {
  readonly __typename?: 'WebhookStats';
  readonly activeWebhooks: Scalars['Int']['output'];
  readonly failedDeliveries: Scalars['Int']['output'];
  readonly successRate: Scalars['Float']['output'];
  readonly successfulDeliveries: Scalars['Int']['output'];
  readonly totalDeliveries: Scalars['Int']['output'];
  readonly totalWebhooks: Scalars['Int']['output'];
};

export type WorkingHoursInput = {
  readonly end: Scalars['String']['input'];
  readonly start: Scalars['String']['input'];
};

export type CreateTaskFromNaturalLanguageMutationVariables = Exact<{
  query: Scalars['String']['input'];
  context?: InputMaybe<AiContextInput>;
}>;


export type CreateTaskFromNaturalLanguageMutation = { readonly __typename?: 'Mutation', readonly createTaskFromNaturalLanguage: { readonly __typename?: 'Task', readonly id: string, readonly title: string, readonly description?: string | null, readonly priority: Priority, readonly dueDate?: string | null, readonly dueTime?: string | null, readonly columnId: string, readonly boardId: string, readonly estimatedDuration?: number | null, readonly status: TaskStatus, readonly position: number, readonly createdAt: string, readonly updatedAt: string, readonly labels: ReadonlyArray<{ readonly __typename?: 'Label', readonly id: string, readonly name: string, readonly color: string }> } };

export type GetAiSuggestedTasksQueryVariables = Exact<{
  context: AiContextInput;
}>;


export type GetAiSuggestedTasksQuery = { readonly __typename?: 'Query', readonly aiSuggestedTasks: ReadonlyArray<{ readonly __typename?: 'Task', readonly id: string, readonly title: string, readonly description?: string | null, readonly priority: Priority, readonly status: TaskStatus, readonly dueDate?: string | null, readonly dueTime?: string | null, readonly estimatedDuration?: number | null, readonly isOverdue: boolean, readonly completionPercentage: number, readonly labels: ReadonlyArray<{ readonly __typename?: 'Label', readonly id: string, readonly name: string, readonly color: string }> }> };

export type NextRecommendedTaskQueryVariables = Exact<{
  boardId: Scalars['ID']['input'];
}>;


export type NextRecommendedTaskQuery = { readonly __typename?: 'Query', readonly nextRecommendedTask?: { readonly __typename?: 'Task', readonly id: string, readonly title: string, readonly description?: string | null, readonly priority: Priority, readonly status: TaskStatus, readonly dueDate?: string | null, readonly dueTime?: string | null, readonly columnId: string, readonly boardId: string, readonly estimatedDuration?: number | null, readonly isOverdue: boolean, readonly completionPercentage: number, readonly labels: ReadonlyArray<{ readonly __typename?: 'Label', readonly id: string, readonly name: string, readonly color: string }>, readonly subtasks: ReadonlyArray<{ readonly __typename?: 'SubTask', readonly id: string, readonly title: string, readonly completed: boolean, readonly position: number }> } | null };

export type OnTaskCreatedSubscriptionVariables = Exact<{
  boardId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type OnTaskCreatedSubscription = { readonly __typename?: 'Subscription', readonly taskCreated: { readonly __typename?: 'Task', readonly id: string, readonly title: string, readonly description?: string | null, readonly priority: Priority, readonly status: TaskStatus, readonly dueDate?: string | null, readonly dueTime?: string | null, readonly columnId: string, readonly boardId: string, readonly position: number, readonly createdAt: string, readonly updatedAt: string, readonly labels: ReadonlyArray<{ readonly __typename?: 'Label', readonly id: string, readonly name: string, readonly color: string }> } };

export type OnTaskUpdatedSubscriptionVariables = Exact<{
  boardId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type OnTaskUpdatedSubscription = { readonly __typename?: 'Subscription', readonly taskUpdated: { readonly __typename?: 'Task', readonly id: string, readonly title: string, readonly description?: string | null, readonly priority: Priority, readonly status: TaskStatus, readonly dueDate?: string | null, readonly dueTime?: string | null, readonly columnId: string, readonly boardId: string, readonly position: number, readonly isOverdue: boolean, readonly completionPercentage: number, readonly updatedAt: string, readonly labels: ReadonlyArray<{ readonly __typename?: 'Label', readonly id: string, readonly name: string, readonly color: string }> } };

export type OnTaskDeletedSubscriptionVariables = Exact<{
  boardId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type OnTaskDeletedSubscription = { readonly __typename?: 'Subscription', readonly taskDeleted: { readonly __typename?: 'Task', readonly id: string, readonly title: string, readonly status: TaskStatus, readonly deletedAt?: string | null } };

export type OnBoardUpdatedSubscriptionVariables = Exact<{
  boardId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type OnBoardUpdatedSubscription = { readonly __typename?: 'Subscription', readonly boardUpdated: { readonly __typename?: 'Board', readonly id: string, readonly name: string, readonly description?: string | null, readonly isShared: boolean, readonly taskCount: number, readonly completedTaskCount: number, readonly updatedAt: string, readonly columns: ReadonlyArray<{ readonly __typename?: 'BoardColumn', readonly id: string, readonly title: string, readonly color?: string | null, readonly position: number, readonly taskCount: number }>, readonly settings: { readonly __typename?: 'BoardSettings', readonly defaultColumnId?: string | null, readonly completedColumnId?: string | null, readonly autoArchiveCompleted: boolean, readonly recycleBinRetentionDays: number } } };


export const CreateTaskFromNaturalLanguageDocument = gql`
    mutation CreateTaskFromNaturalLanguage($query: String!, $context: AIContextInput) {
  createTaskFromNaturalLanguage(query: $query, context: $context) {
    id
    title
    description
    priority
    dueDate
    dueTime
    labels {
      id
      name
      color
    }
    columnId
    boardId
    estimatedDuration
    status
    position
    createdAt
    updatedAt
  }
}
    `;
export type CreateTaskFromNaturalLanguageMutationFn = Apollo.MutationFunction<CreateTaskFromNaturalLanguageMutation, CreateTaskFromNaturalLanguageMutationVariables>;

/**
 * __useCreateTaskFromNaturalLanguageMutation__
 *
 * To run a mutation, you first call `useCreateTaskFromNaturalLanguageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTaskFromNaturalLanguageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTaskFromNaturalLanguageMutation, { data, loading, error }] = useCreateTaskFromNaturalLanguageMutation({
 *   variables: {
 *      query: // value for 'query'
 *      context: // value for 'context'
 *   },
 * });
 */
export function useCreateTaskFromNaturalLanguageMutation(baseOptions?: Apollo.MutationHookOptions<CreateTaskFromNaturalLanguageMutation, CreateTaskFromNaturalLanguageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTaskFromNaturalLanguageMutation, CreateTaskFromNaturalLanguageMutationVariables>(CreateTaskFromNaturalLanguageDocument, options);
      }
export type CreateTaskFromNaturalLanguageMutationHookResult = ReturnType<typeof useCreateTaskFromNaturalLanguageMutation>;
export type CreateTaskFromNaturalLanguageMutationResult = Apollo.MutationResult<CreateTaskFromNaturalLanguageMutation>;
export type CreateTaskFromNaturalLanguageMutationOptions = Apollo.BaseMutationOptions<CreateTaskFromNaturalLanguageMutation, CreateTaskFromNaturalLanguageMutationVariables>;
export const GetAiSuggestedTasksDocument = gql`
    query GetAISuggestedTasks($context: AIContextInput!) {
  aiSuggestedTasks(context: $context) {
    id
    title
    description
    priority
    status
    dueDate
    dueTime
    labels {
      id
      name
      color
    }
    estimatedDuration
    isOverdue
    completionPercentage
  }
}
    `;

/**
 * __useGetAiSuggestedTasksQuery__
 *
 * To run a query within a React component, call `useGetAiSuggestedTasksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAiSuggestedTasksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAiSuggestedTasksQuery({
 *   variables: {
 *      context: // value for 'context'
 *   },
 * });
 */
export function useGetAiSuggestedTasksQuery(baseOptions: Apollo.QueryHookOptions<GetAiSuggestedTasksQuery, GetAiSuggestedTasksQueryVariables> & ({ variables: GetAiSuggestedTasksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAiSuggestedTasksQuery, GetAiSuggestedTasksQueryVariables>(GetAiSuggestedTasksDocument, options);
      }
export function useGetAiSuggestedTasksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAiSuggestedTasksQuery, GetAiSuggestedTasksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAiSuggestedTasksQuery, GetAiSuggestedTasksQueryVariables>(GetAiSuggestedTasksDocument, options);
        }
export function useGetAiSuggestedTasksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAiSuggestedTasksQuery, GetAiSuggestedTasksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAiSuggestedTasksQuery, GetAiSuggestedTasksQueryVariables>(GetAiSuggestedTasksDocument, options);
        }
export type GetAiSuggestedTasksQueryHookResult = ReturnType<typeof useGetAiSuggestedTasksQuery>;
export type GetAiSuggestedTasksLazyQueryHookResult = ReturnType<typeof useGetAiSuggestedTasksLazyQuery>;
export type GetAiSuggestedTasksSuspenseQueryHookResult = ReturnType<typeof useGetAiSuggestedTasksSuspenseQuery>;
export type GetAiSuggestedTasksQueryResult = Apollo.QueryResult<GetAiSuggestedTasksQuery, GetAiSuggestedTasksQueryVariables>;
export function refetchGetAiSuggestedTasksQuery(variables: GetAiSuggestedTasksQueryVariables) {
      return { query: GetAiSuggestedTasksDocument, variables: variables }
    }
export const NextRecommendedTaskDocument = gql`
    query NextRecommendedTask($boardId: ID!) {
  nextRecommendedTask(boardId: $boardId) {
    id
    title
    description
    priority
    status
    dueDate
    dueTime
    labels {
      id
      name
      color
    }
    columnId
    boardId
    estimatedDuration
    isOverdue
    completionPercentage
    subtasks {
      id
      title
      completed
      position
    }
  }
}
    `;

/**
 * __useNextRecommendedTaskQuery__
 *
 * To run a query within a React component, call `useNextRecommendedTaskQuery` and pass it any options that fit your needs.
 * When your component renders, `useNextRecommendedTaskQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNextRecommendedTaskQuery({
 *   variables: {
 *      boardId: // value for 'boardId'
 *   },
 * });
 */
export function useNextRecommendedTaskQuery(baseOptions: Apollo.QueryHookOptions<NextRecommendedTaskQuery, NextRecommendedTaskQueryVariables> & ({ variables: NextRecommendedTaskQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NextRecommendedTaskQuery, NextRecommendedTaskQueryVariables>(NextRecommendedTaskDocument, options);
      }
export function useNextRecommendedTaskLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NextRecommendedTaskQuery, NextRecommendedTaskQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NextRecommendedTaskQuery, NextRecommendedTaskQueryVariables>(NextRecommendedTaskDocument, options);
        }
export function useNextRecommendedTaskSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<NextRecommendedTaskQuery, NextRecommendedTaskQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NextRecommendedTaskQuery, NextRecommendedTaskQueryVariables>(NextRecommendedTaskDocument, options);
        }
export type NextRecommendedTaskQueryHookResult = ReturnType<typeof useNextRecommendedTaskQuery>;
export type NextRecommendedTaskLazyQueryHookResult = ReturnType<typeof useNextRecommendedTaskLazyQuery>;
export type NextRecommendedTaskSuspenseQueryHookResult = ReturnType<typeof useNextRecommendedTaskSuspenseQuery>;
export type NextRecommendedTaskQueryResult = Apollo.QueryResult<NextRecommendedTaskQuery, NextRecommendedTaskQueryVariables>;
export function refetchNextRecommendedTaskQuery(variables: NextRecommendedTaskQueryVariables) {
      return { query: NextRecommendedTaskDocument, variables: variables }
    }
export const OnTaskCreatedDocument = gql`
    subscription OnTaskCreated($boardId: ID) {
  taskCreated(boardId: $boardId) {
    id
    title
    description
    priority
    status
    dueDate
    dueTime
    labels {
      id
      name
      color
    }
    columnId
    boardId
    position
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useOnTaskCreatedSubscription__
 *
 * To run a query within a React component, call `useOnTaskCreatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnTaskCreatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnTaskCreatedSubscription({
 *   variables: {
 *      boardId: // value for 'boardId'
 *   },
 * });
 */
export function useOnTaskCreatedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<OnTaskCreatedSubscription, OnTaskCreatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnTaskCreatedSubscription, OnTaskCreatedSubscriptionVariables>(OnTaskCreatedDocument, options);
      }
export type OnTaskCreatedSubscriptionHookResult = ReturnType<typeof useOnTaskCreatedSubscription>;
export type OnTaskCreatedSubscriptionResult = Apollo.SubscriptionResult<OnTaskCreatedSubscription>;
export const OnTaskUpdatedDocument = gql`
    subscription OnTaskUpdated($boardId: ID) {
  taskUpdated(boardId: $boardId) {
    id
    title
    description
    priority
    status
    dueDate
    dueTime
    labels {
      id
      name
      color
    }
    columnId
    boardId
    position
    isOverdue
    completionPercentage
    updatedAt
  }
}
    `;

/**
 * __useOnTaskUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnTaskUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnTaskUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnTaskUpdatedSubscription({
 *   variables: {
 *      boardId: // value for 'boardId'
 *   },
 * });
 */
export function useOnTaskUpdatedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<OnTaskUpdatedSubscription, OnTaskUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnTaskUpdatedSubscription, OnTaskUpdatedSubscriptionVariables>(OnTaskUpdatedDocument, options);
      }
export type OnTaskUpdatedSubscriptionHookResult = ReturnType<typeof useOnTaskUpdatedSubscription>;
export type OnTaskUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnTaskUpdatedSubscription>;
export const OnTaskDeletedDocument = gql`
    subscription OnTaskDeleted($boardId: ID) {
  taskDeleted(boardId: $boardId) {
    id
    title
    status
    deletedAt
  }
}
    `;

/**
 * __useOnTaskDeletedSubscription__
 *
 * To run a query within a React component, call `useOnTaskDeletedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnTaskDeletedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnTaskDeletedSubscription({
 *   variables: {
 *      boardId: // value for 'boardId'
 *   },
 * });
 */
export function useOnTaskDeletedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<OnTaskDeletedSubscription, OnTaskDeletedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnTaskDeletedSubscription, OnTaskDeletedSubscriptionVariables>(OnTaskDeletedDocument, options);
      }
export type OnTaskDeletedSubscriptionHookResult = ReturnType<typeof useOnTaskDeletedSubscription>;
export type OnTaskDeletedSubscriptionResult = Apollo.SubscriptionResult<OnTaskDeletedSubscription>;
export const OnBoardUpdatedDocument = gql`
    subscription OnBoardUpdated($boardId: ID) {
  boardUpdated(boardId: $boardId) {
    id
    name
    description
    columns {
      id
      title
      color
      position
      taskCount
    }
    settings {
      defaultColumnId
      completedColumnId
      autoArchiveCompleted
      recycleBinRetentionDays
    }
    isShared
    taskCount
    completedTaskCount
    updatedAt
  }
}
    `;

/**
 * __useOnBoardUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnBoardUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnBoardUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnBoardUpdatedSubscription({
 *   variables: {
 *      boardId: // value for 'boardId'
 *   },
 * });
 */
export function useOnBoardUpdatedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<OnBoardUpdatedSubscription, OnBoardUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnBoardUpdatedSubscription, OnBoardUpdatedSubscriptionVariables>(OnBoardUpdatedDocument, options);
      }
export type OnBoardUpdatedSubscriptionHookResult = ReturnType<typeof useOnBoardUpdatedSubscription>;
export type OnBoardUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnBoardUpdatedSubscription>;