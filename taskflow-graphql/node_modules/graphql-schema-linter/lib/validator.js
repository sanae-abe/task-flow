"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateSchemaDefinition = validateSchemaDefinition;

var _graphql = require("graphql");

var _validation = require("graphql/validation");

var _buildASTSchema = require("graphql/utilities/buildASTSchema");

var _error = require("graphql/error");

var _validate = require("graphql/validation/validate");

var _validate2 = require("graphql/type/validate");

var _inline_configuration = require("./inline_configuration");

var _validation_error = require("./validation_error");

var _find_schema_nodes = require("./find_schema_nodes");

function validateSchemaDefinition(inputSchema, rules, configuration) {
  let ast;
  let parseOptions = {};

  if (configuration.getOldImplementsSyntax()) {
    parseOptions.allowLegacySDLImplementsInterfaces = true;
  }

  try {
    ast = (0, _graphql.parse)(inputSchema.definition, parseOptions);
  } catch (e) {
    if (e instanceof _error.GraphQLError) {
      e.ruleName = 'graphql-syntax-error';
      return [e];
    } else {
      throw e;
    }
  }

  let schemaErrors = (0, _validate.validateSDL)(ast);

  if (schemaErrors.length > 0) {
    return sortErrors(schemaErrors.map(error => {
      return new _validation_error.ValidationError('invalid-graphql-schema', error.message, error.nodes);
    }));
  }

  const schema = (0, _buildASTSchema.buildASTSchema)(ast, {
    commentDescriptions: configuration.getCommentDescriptions(),
    assumeValidSDL: true,
    assumeValid: true
  });
  schema.__validationErrors = undefined;
  schemaErrors = (0, _validate2.validateSchema)(schema);

  if (schemaErrors.length > 0) {
    return sortErrors(schemaErrors.map(error => {
      return new _validation_error.ValidationError('invalid-graphql-schema', error.message, error.nodes || ast);
    }));
  }

  const rulesWithConfiguration = rules.map(rule => {
    return ruleWithConfiguration(rule, configuration);
  });

  const isGraphQLVersion15 = _graphql.version.startsWith('15');

  const validateOptions = {
    maxErrors: Number.MAX_SAFE_INTEGER
  };
  const errors = (0, _validation.validate)(schema, ast, rulesWithConfiguration, isGraphQLVersion15 ? undefined : validateOptions, isGraphQLVersion15 ? validateOptions : undefined);
  const sortedErrors = sortErrors(errors);
  const errorFilters = [inlineConfigErrorFilter(ast, inputSchema), ignoreListErrorFilter(schema, configuration)];
  const filteredErrors = sortedErrors.filter(error => errorFilters.every(filter => filter(error)));
  return filteredErrors;
}

function sortErrors(errors) {
  return errors.sort((a, b) => {
    return a.locations[0].line - b.locations[0].line;
  });
}

function ruleWithConfiguration(rule, configuration) {
  if (rule.length == 2) {
    return function (context) {
      return rule(configuration, context);
    };
  } else {
    return rule;
  }
}

function inlineConfigErrorFilter(ast, inputSchema) {
  const inlineConfigs = (0, _inline_configuration.extractInlineConfigs)(ast);

  if (inlineConfigs.length === 0) {
    return () => true;
  }

  const schemaSourceMap = inputSchema.sourceMap;
  return error => {
    let shouldApplyRule = true;
    const errorLine = error.locations[0].line;
    const errorFilePath = schemaSourceMap.getOriginalPathForLine(errorLine);

    for (const config of inlineConfigs) {
      // Skip inline configs that don't modify this error's rule
      if (!config.rules.includes(error.ruleName)) {
        continue;
      } // Skip inline configs that aren't in the same source file as the errored line


      const configFilePath = schemaSourceMap.getOriginalPathForLine(config.line);

      if (configFilePath !== errorFilePath) {
        continue;
      } // When 'disable-line': disable the rule if the error line and the command line match


      if (config.command === 'disable-line' && config.line === errorLine) {
        shouldApplyRule = false;
        break;
      } // Otherwise, last command wins (expected order by line)


      if (config.line < errorLine) {
        if (config.command === 'enable') {
          shouldApplyRule = true;
        } else if (config.command === 'disable') {
          shouldApplyRule = false;
        }
      }
    }

    return shouldApplyRule;
  };
}

function ignoreListErrorFilter(schema, configuration) {
  const ignoreList = configuration.getIgnoreList();
  const index = {};

  for (const [rule, scopes] of Object.entries(ignoreList)) {
    index[rule] = (0, _find_schema_nodes.findSchemaNodes)(scopes, schema);
  }

  return error => {
    if (error.ruleName) {
      const subjects = index[error.ruleName];
      const ignore = subjects === null || subjects === void 0 ? void 0 : subjects.has(error.nodes[0]);
      return !ignore;
    } else {
      return true;
    }
  };
}